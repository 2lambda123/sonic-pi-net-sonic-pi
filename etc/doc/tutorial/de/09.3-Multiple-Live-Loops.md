# Mehrfache Live Loops

Schau dir den folgenden Live Loop an:

```
live_loop :foo do
  play 50
  sleep 1
end
```

Vielleicht fragst du dich, warum er den Namen `:foo` braucht. Dieser Name ist wichtig, weil er sicherstellt, dass dieser Live Loop unterschiedlich zu allen anderen Live Loops ist.

*Es können nie zwei Live Loops mit dem selben Namen gleichzeitig laufen*.

Das bedeutet, dass wir unterschiedliche Namen vergeben müssen, um mehrere gleichzeitig laufende Live Loops zu haben zu können. 

```
live_loop :foo do
  use_synth :prophet
  play :c1, release: 8, cutoff: rrand(70, 130)
  sleep 8
end

live_loop :bar do
  sample :bd_haus
  sleep 0.5
end
```

Jetzt kannst du beide Live Loops unabhängig voneinander aktualisieren und alles funktioniert einfach.

## Live Loops Synchronisieren

One thing you might have already noticed is that live loops work
automatically with the thread cue mechanism we explored
previously. Every time the live loop loops, it generates a new `cue`
event with the name of the live loop. We can therefore `sync` on these
cues to ensure our loops are in sync without having to stop anything.

Consider this badly synced code:

```
live_loop :foo do
  play :e4, release: 0.5
  sleep 0.4
end

live_loop :bar do
  sample :bd_haus
  sleep 1
end
```

Let's see if we can fix the timing and sync without stopping it. First,
let's fix the `:foo` loop to make the sleep a factor of 1 - something like
`0.5` will do:

```
live_loop :foo do
  play :e4, release: 0.5
  sleep 0.5
end

live_loop :bar do
  sample :bd_haus
  sleep 1
end
```

We're not quite finished yet though - you'll notice that the beats don't
quite line up correctly. This is because the loops are *out of
phase*. Let's fix that by syncing one to the other:

```
live_loop :foo do
  play :e4, release: 0.5
  sleep 0.5
end

live_loop :bar do
  sync :foo
  sample :bd_haus
  sleep 1
end
```

Wow, everything is now perfectly in time - all without stopping.

Now, go forth and live code with live loops!
