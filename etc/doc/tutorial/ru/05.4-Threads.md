5.4 Threads

# Потоки

Итак, ты написал чумовую бас-партию и заводной ритм. Как сыграть обе эти части
одновременно? Одно из решений - переплести их вместе вручную - играть небольшую
чать баса, затем немного от ударных, потом еще бас... Однако, вскоре становится
очень сложно даже думать о том, как разместить это все во времени, особенно если
ты начинаешь добавлять еще элементы.

Что если бы Sonic Pi мог соединять партии инструментов за тебя автоматически?
Вообще-то это возможно, и для этого тебе надо использовать специальную вещь,
которая называется *поток выполнения*.

## Бесконечные циклы

Дабы не усложнять наш пример, представим, что это и есть крутой ритм и потрясающая
бас-партия:

```
loop do
  sample :drum_heavy_kick
  sleep 1
end

loop do
  use_synth :fm
  play 40, release: 0.2
  sleep 0.5
end
```

Как мы уже обсуждали, циклы - это *черные дыры* в программе. Как только начинает
выполняться цикл, то выйти из него уже нельзя, пока не нажата кнопка Stop. Как
сыграть сразу оба цикла в то же самое время? Надо сообщить Sonic Pi, что мы хотим
начать что-то вместе с остальной частью кода. Вот тут-то нам потоки и придут на
помощь.

## Спасительные потоки

```
in_thread do
  loop do
    sample :drum_heavy_kick
    sleep 1
  end
end

loop do
  use_synth :fm
  play 40, release: 0.2
  sleep 0.5
end
```

Обернув первый цикл в do/end блок типа `in_thread`, мы заставляем Sonic Pi
выполнять содержимое блока do/end *точно* в то же самое время, когда следующее
выражение после блока do/end. В нашем примере таковым является второй цикл.
Попробуй, и ты услышишь, как ударные и бас переплетаются вместе!

Теперь, что если мы хотим добавить синт поверх. Что-то типа:

```
in_thread do
  loop do
    sample :drum_heavy_kick
    sleep 1
  end
end

loop do
  use_synth :fm
  play 40, release: 0.2
  sleep 0.5
end

loop do
  use_synth :zawa
  play 52, release: 2.5, phase: 2, amp: 0.5
  sleep 2
end
```

Опять та же самая проблема. Первый цикл воспроизводится вместе со вторым из-за
`in_thread`. Но *третий цикл никогда не достигается*. То есть нам нужен еще один
поток:

```
in_thread do
  loop do
    sample :drum_heavy_kick
    sleep 1
  end
end

in_thread do
  loop do
    use_synth :fm
    play 40, release: 0.2
    sleep 0.5
  end
end

loop do
  use_synth :zawa
  play 52, release: 2.5, phase: 2, amp: 0.5
  sleep 2
end
```

## Течет, как поток

Тебя модет удивить, что при нажатии кнопки Run тоже создается поток для выполнения
кода. Вот почему нажимание ее несколько раз наслаивает звуки друг поверх друга.
Запуски автоматически сливают звуки, потому что они сами являются потоками.

## Область видимости

По мере овладения секретами мастерства Sonic Pi ты узнаешь, что потоки - это самые
важные строительные блоки твоей музыки. Не последним их качеством является также
способность изолировать то, что называется *текущей установкой*, от других потоков.
Что это значит? Ну, когда ты переключаешь синт при помощи `use_synth`, то, на самом
деле, ты просто меняешь синт в *текущем потоке* - ни в одном другом потоке он не
изменится. Давай посмотрим на это в действии:

```
play 50
sleep 1

in_thread do
  use_synth :tb303
  play 50
end

sleep 1
play 50

```

Обрати внимание, как звук всередине отличался от остальных? Команда `use_synth`
применилась только к потоку, где она была выполнена, а не к окружающему главному
потоку выполнения программы.

## Наследование

Когда ты создаешь новый поток, вызывая `in_thread`, то он автоматически наследует
все текущие настройки из родительского потока. Проверим это:

```
use_synth :tb303
play 50
sleep 1

in_thread do
  play 55
end
```

Заметил, что вторая нота воспроизводится на `:tb303` синте несмотря на то, что это
происходит в отдельном потоке? Любые регулировки, устанавливаемые различными
`use_*` функциями, будут вести себя аналогично.

При создании потоки наследуют все установки от своего родителя, но любые последующие
изменения не имеют обратного эффекта.

## Наименование потоков

Наконец, мы можем называть наши потоки:

```
in_thread(name: :bass) do
  loop do
    use_synth :prophet
    play chord(:e2, :m7).choose, release: 0.6
    sleep 0.5
  end
end

in_thread(name: :drums) do
  loop do
    sample :elec_snare
    sleep 1
  end
end
```

Посмотри на панель сообщений, когда этот код выполняется. Видишь, как появляются
сообщения, в которые включены имена потоков?

```
[Run 36, Time 4.0, Thread :bass]
 |- synth :prophet, {release: 0.6, note: 47}
```

## Каждый поток со своим именем

Последнее, что тебе надо узнать об именованных потоках, это то, что только один
поток с определенным именем может выполняться одновременно. Рассмотрим следующий
код:

```
in_thread do
  loop do
    sample :loop_amen
    sleep sample_duration :loop_amen
  end
end
```

Скопируй этот фрагмент в буфер редактора и нажми кнопку Run. Нажми ее еще пару раз.
Получилась какафония от того, что много повторений амен-брейка смешались вместе.
Ладно, нажимай Stop.

Это то самое поведение, которое нам не раз уже доводилось наблюдать. Если нажимать
кнопку Run, то новый звук накладывается поверх уже играющего. Поэтому, если у тебя
есть цикл, и ты нажмешь кнопку Run три раза, то получится три слоя циклов, звучащих
вместе.

Но ситуация меняется с именованными потоками:

```
in_thread(name: :amen) do
  loop do
    sample :loop_amen
    sleep sample_duration :loop_amen
  end
end
```

Теперь попробуй понажимать кнопку Run с этим кодом. Ты услышишь только один цикл
амен-брейк. В сообщениях ты также увидишь:

```
==> Skipping thread creation: thread with name :amen already exists.
```

Sonic Pi сообщает тебе, что поток поток с именем `:amen` уже играет, так что он
создаст еще одного такого же.

Такое поведение может не показаться тебе очень полезным сейчас. Но в дальнейшем
ты еще вспомнишь о нем, когда мы начнем кодировать вживую...
