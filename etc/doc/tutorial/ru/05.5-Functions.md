5.5 Functions

# Функции

Когда ты станешь писать большое количество кода, тебе может потребоваться способ
организовать и структурировать элементы, чтобы они выглядели чище, и их было бы
проще понять. Функции - это очень мощный способ достичь этого. Они позволяют нам
давать имена фрагментам кода. Посмотрим, как это работает.

## Определение функций

```
define :foo do
  play 50
  sleep 1
  play 55
  sleep 2
end
```

Мы определили новую функцию, называющуюся `foo`. Мы сделали это при помощи нашего
старого знакомого блока do/end и магического слова `define`, за которым следует
имя нашей функции. Необязательно было называть ее `foo`. Можно было придумать какое
угодно название, к примеру `bar` или `baz`. Но, вообще-то, лучше всего, когда имя
что-то означает, например `main_section` (главная секция) или `lead_riff` (основной
рифф).

Не забывай ставить двоеточие `:` перед именем функции, когда ты определяешь ее.

## Вызов функций

Когда наша функция определена, мы можем вызвать ее, просто написав ее имя:

```
define :foo do
  play 50
  sleep 1
  play 55
  sleep 0.5
end

foo

sleep 1

2.times do
  foo
end
```

Можно даже использовать `foo` внутри повторяющихся блоков, а также везде, где мы
могли бы добавить `play` или `sample`. Нам это дает отличный прием для самовыражения
и создания новых обозначений в наших композициях.

## Функции сохраняются между запусками

Пока что, всякий раз при нажатии кнопки Run Sonic Pi начинал с чистого листа. Ему
ничего не известно кроме того, что находится в буфере редактора. Нельзя ссылаться
на код в другом буфере или другом потоке. Однако, функции меняют это. Когда ты
определяешь функцию, Sonic Pi *запоминает* ее. Попробуем. Удали весь код в буфере
и замени его вот на что:

```
foo
```

Нажми кнопку Run и убедись, что твоя функция играет. Куда же пропал код? Откуда
Sonic Pi знал, что играть? Sonic Pi просто вспомнил твою функцию даже после удаления
ее из буфера. Он вспомнил, что ты напечатал. Это работает только с функциями, которые
создаются при помощи `define` (и `defonce`)

## Функции с параметрами

Тебе, возможно, будет интересно узнать, что твою функцию можно научить принимать
аргументы, прямо как `rrand` принимает значения минимума и максимума. Посмотрим
как это выглядит:

```
define :my_player do |n|
  play n
end

my_player 80
sleep 0.5
my_player 90
```

Пример не очень интересный, но он показывает, что имеется в виду. Мы создали
нашу собственную версию `play` с параметрами и назвали ее `my_player`.

Параметры должны описываться после ключевого слова `do` блока `define`. Он должны
быть окружены вертикальными стойками `|` и разделены запятыми `,`. Любые слова
могут служить именами параметров.

Магия происходит внутри блока `define`. Там можно использовать имена параметров,
как если бы они были настоящими значениями. В этом примере я проигрываю ноту `n`.
Ты можешь думать о параметрах как о неких обещаниях о том, что при выполнении кода
они будут заменены их значениями. Это достигается передачей параметра функции при
ее вызове. Чтобы сыграть ноту 80, я пишу `my_player 80`. Тогда внутри определения
функции `n` меняется на 80, так что `play n` превращается в `play 80`. В следующий
раз, когда я вызываю `my_player 90`, вместо `n` появляется 90, поэтому `play n`
становится `play 90`.

Рассмотрим что-нибудь поинтереснее:

```
define :chord_player do |root, repeats|
  repeats.times do
    play chord(root, :minor), release: 0.3
    sleep 0.5
  end
end

chord_player :e3, 2
sleep 0.5
chord_player :a3, 3
chord_player :g3, 4
sleep 0.5
chord_player :e3, 3

```

Я использовал `repeats`, как если бы он был числов в строке `repeats.times do`.
Еще я использовал `root` в качестве названия ноты для `play`.

Видишь, как можно писать нечто очень выразительное и в то же время простое для
чтения, если перенести большую часть логики в функцию!
