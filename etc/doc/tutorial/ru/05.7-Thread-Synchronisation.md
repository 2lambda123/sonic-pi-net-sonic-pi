5.7 Thread Synchronisation

# Синхронизация потоков

Когда у тебя начнет достаточно хорошо получаться кодировать вживую с достаточно
большим количеством потоков, выполняющихся одновременно, ты, скорее всего, заметишь,
что очень легко допустить ошибку, которая может прервать поток. Ничего страшного
в этом нет, так как поток может быть перезапущен простым нажатием кнопки Run.
Однако, после перезапуска потока он будет играть *невпопад* с другими.

## Унаследованное время

Как мы обсуждали ранее, новые потоки, созданные при помощи `in_thread` наследуют
все настройки от родительского потока. Они включают и текущую метку времени. Это
означает, что потоки всегда синхронизированы друг с другом после одновременного
их запуска.

Но, когда ты стартуешь поток сам по себе, то внутри него ведется собственный
отсчет времени, который вряд ли совпадет с каким-либо из других активных потоков.

## Функции cue и sync

В Sonic Pi решением этой проблемы являются функции `cue` и `sync`.

`cue` позволяет нам отправлять сигнал пульса всем другим потокам. По умолчанию,
другие потоки не слушают и пропускают эти сообщения. Однако, поток может легко
заявить о своей заинтересованности, вызвав функцию `sync`.

Важно осознавать, что `sync` похожа на `sleep` тем, что она останавливает текущий
поток, и тот некоторое время ничего не делает. Для `sleep` время простоя указывается,
а, вызвав `sync`, ты не знаешь сколько времени оно продлится, потому что `sync`
ждет следующий `cue` от другого потока. Это может случиться скоро или нет.

Давай выясним немного больше деталей:

```
in_thread do
  loop do
    cue :tick
    sleep 1
  end
end

in_thread do
  loop do
    sync :tick
    sample :drum_heavy_kick
  end
end
```

Здесь у нас два потока. Один работает, как метроном. Он не играет никаких звуков,
но только отправляет `:tick` сигналы пульса на каждый отсчет. Второй поток
синхронизируется с сообщениями `tick`. Когда он получает его, то наследует временную
отметку потока, вызвавшего `cue`, и продолжает выполнение.

В результате мы будем слышать сэмпл `:drum_heavy_kick` в тот самый момент, когда
другой поток отправляет `:tick` сигнал. Даже если два потока стартованы не
одновременно, это все равно будет происходить:

```
in_thread do
  loop do
    cue :tick
    sleep 1
  end
end

sleep(0.3)

in_thread do
  loop do
    sync :tick
    sample :drum_heavy_kick
  end
end
```

Типичным эффектом этого капризного вызова `sleep` будет расхождения второго
потока с первым. Однако, так как мы используем `cue` и `sync`, то мы автоматически
синхронизируем потоки и избегаем любых случайных временных сдвигов.

## Имена сигналов

Для сигналов `cue` можно использовать любые названия, а не только `:tick`. Просто
следи за тем, чтобы все остальные потоки вызывали `sync` с правильным именем.
Иначе они остановятся навсегда (или по крайней мере пока не нажмешь кнопку Stop).

Попробуем что-нибудь с несколькими названиями `cue`:

```
in_thread do
  loop do
    cue [:foo, :bar, :baz].choose
    sleep 0.5
  end
end

in_thread do
  loop do
    sync :foo
    sample :elec_beep
  end
end

in_thread do
  loop do
    sync :bar
    sample :elec_flip
  end
end

in_thread do
  loop do
    sync :baz
    sample :elec_blup
  end
end
```

Тут у нас есть цикл главного `cue`, который отправляет сигнал. Случайным образом
сигнал может быть `:foo`, `:bar` или `:baz`. Еще есть три цикла в потоках, которые
синхронизируются с каждым из этих сигналов независимо и воспроизводят разные
сэмплы. Чистый эффект от этого кода в том, что каждые полсекунды мы слышим звук,
так как каждый из `sync`-потоков случайным образом синхронизируется с потоком `cue`
и проигрывает свой сэмпл.

Конечно же, код будет работать также, если ты расположишь потоки в обратном порядке,
поскольку потоки будут дожидаться следующего `cue`.
